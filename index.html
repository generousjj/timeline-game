<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timeline Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background-color: white;
      color: black;
    }

    .container {
      display: flex;
      justify-content: space-between;
      height: 100%;
      width: 100%;
    }

    .deck {
      /*min-height: 100px;
      min-width: 200px;*/
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 40%;
      height: 100%;
      padding: 0 20px;
      background-color: #cccccc;
    }



    .next-button {
      display: hidden;
      /*block
            /*position: absolute;*/
      margin-top: 10px;
      /*transform: translateY(-50%);*/
    }

    .card-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 60%;
      height: 100%;
      padding: 0 20px;
      overflow-y: auto;
      background-color: #e0e0e0;
    }

    .card-container {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      align-items: center;
      width: 100%;
      max-width: 500px;
      /* Adjust this value based on the desired width */
    }

    .card {
      padding: 10px 20px;
      margin: 10px;
      border: 1px solid #999;
      border-radius: 5px;
      cursor: grab;
      user-select: none;
    }

    .dragged {
      cursor: grabbing;
      opacity: 0.5;
      position: fixed;
    }

    .placeholder {
      /*display: none;*/
      padding: 10px 20px;
      margin: 10px;
      border: 2px dashed #00f;
      border-radius: 5px;
      color: #00f;
      font-weight: bold;
      background-color: #b19cd9;
    }

    .theme-toggle {
      position: fixed;
      top: 10px;
      left: 10px;
      font-size: 24px;
      cursor: pointer;
    }

    .check-results-button {
      position: fixed;
      bottom: 10px;
      left: 10px;
    }

    .message-box {
      position: fixed;
      top: 20px;
      left: 50%;
      /*left: 10px;*/
      transform: translateX(-50%);
      background-color: rgba(241, 241, 241, 0.8);
      border: 1px solid #ccc;
      padding: 25px;
      border-radius: 4px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    @keyframes fadeOut {
      0% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }
    
    .message-box.fade-out {
      animation: fadeOut 1s forwards;
    }

    .event-date {
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .message-close {
      position: absolute;
      top: 5px;
      right: 10px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
    }

    body.dark-mode {
      background-color: #2c3e50;
      color: white;
    }
    
    .deck.dark-mode {
      background-color: #34495e;
    }
    
    .card-area.dark-mode {
      background-color: #4b6584;
    }
    
    .message-box.dark-mode {
      background-color: rgba(66, 69, 73, 0.8);
    }
    
    .sortable-ghost {
      transform: scale(1.1);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    .sortable-fallback {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      background-color: #f6f6f6;
      pointer-events: none;
    }

    .hidden {
      display: none;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
</head>

<body>

  <div class="container">
    <div class="deck">
      <button class="next-button" onclick="drawCard()">Skip</button>
    </div>
    <div class="card-area">
      <div class="card-container">
      </div>
      <div class="placeholder">Drag cards from the left to play!</div>
    </div>
  </div>
  <button id="check-results-button" class="check-results-button" onclick=checkResults() disabled>Check Results</button>
  <span class="theme-toggle">🌙</span>
  <div id="message-box" class="message-box hidden">
    <span id="message-text"></span>
    <button id="message-close" class="message-close">&times;</button>
  </div>
  <script>

    const queryString = window.location.search;
    console.log(queryString)
    const urlParams = new URLSearchParams(queryString);
    console.log(urlParams)
    const isDark = urlParams.get('dark');
    console.log(isDark)

    
    const deck = document.querySelector('.deck');
    const skipBtn = document.querySelector('.next-button');
    const cardArea = document.querySelector('.card-area');
    const checkBtn = document.querySelector('.check-results-button');
    const placeholder = document.querySelector('.placeholder');
    const themeToggle = document.querySelector('.theme-toggle');
    const cardContainer = document.querySelector('.card-container');

    const flashcards = [
      {name: 'Event 1', date: 1900},
      {name: 'Event 2', date: 1910},
      {name: 'Event 3', date: 1920},
      // Add more cards here
    ];

    let isDarkMode;
    
    document.addEventListener('DOMContentLoaded', (event) => {
      if (isDark === 'enabled') {
        toggleDarkMode();
      }
    });
    
    let draggedCard = null;
    let currentCardIndex = 0;
    let cardDeck = [...flashcards];
    let hasInteracted = false;

    function shuffle(array) {

      console.log(document.getElementById('check-results-button').textContent)
      
      let currentIndex = array.length, temporaryValue, randomIndex;

      while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }

      return array;
    }

    function drawCard() {
      if (currentCardIndex >= cardDeck.length) {
        skipBtn.disabled = true;
        //checkResults();
        return;
      }

      const cardData = cardDeck[currentCardIndex];

      const existingTopCard = document.querySelector('.top-card');
      if (existingTopCard) {
        existingTopCard.classList.remove('top-card');
      }

      newCard = document.createElement('div');
      newCard.textContent = cardData.name;
      newCard.dataset.date = cardData.date;
      newCard.style.visibility = 'visible';
      newCard.classList.add('card', 'top-card');
      setupCardEvents(newCard);
      deck.appendChild(newCard);
      if (existingTopCard) {
        deck.removeChild(existingTopCard);
      }
      console.log(document.getElementById('check-results-button').textContent)
    }

    function updateCheckResultsButton() {
      const checkResultsButton = document.getElementById('check-results-button');
      if (cardContainer.children.length > 0) {
        checkResultsButton.disabled = false;
      } else {
        checkResultsButton.disabled = true;
      }
    }

    function setupCardEvents(card) {
      card.addEventListener('mousedown', (e) => {
        e.preventDefault();

        if (card.parentNode === deck) {
          draggedCard = card.cloneNode(true);
          setupCardEvents(draggedCard);
          cardArea.appendChild(draggedCard);
          card.style.visibility = 'hidden';
          placeholder.style.display = 'none';

          draggedCard.classList.add('dragged');
          draggedCard.style.left = `${e.clientX - draggedCard.offsetWidth / 2}px`;
          draggedCard.style.top = `${e.clientY - draggedCard.offsetHeight / 2}px`;

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        }
      });

      console.log(document.getElementById('check-results-button').textContent)

    }

    function onMouseMove(e) {
      e.preventDefault();
      if (!draggedCard) {
        return;
      }
    
      draggedCard.style.left = `${e.clientX - draggedCard.offsetWidth / 2}px`;
      draggedCard.style.top = `${e.clientY - draggedCard.offsetHeight / 2}px`;

      const cardContainerRect = cardContainer.getBoundingClientRect();
      const cardRect = draggedCard.getBoundingClientRect();
      const y = e.clientY;

      if (y < cardContainerRect.top || y > cardContainerRect.bottom) {
        return;
      }

      const closestCard = Array.from(cardContainer.children)
        .filter(child => child !== draggedCard && child !== placeholder)
        .reduce((closest, child) => {
          const childRect = child.getBoundingClientRect();
          const offset = y - childRect.top - childRect.height / 2;

          if (offset < 0 && offset > closest.offset) {
            return {offset, element: child};
          } else {
            return closest;
          }
        }, {offset: Number.NEGATIVE_INFINITY});

      const placeholderRect = placeholder.getBoundingClientRect();
      placeholder.style.height = `${draggedCard.offsetHeight / 2}px`;
      placeholder.style.width = `${draggedCard.offsetWidth}px`;


      if (placeholder.nextSibling !== closestCard.element) {
        cardContainer.insertBefore(placeholder, closestCard.element);
      }
    }

    function onMouseUp(e) {
      e.preventDefault();

      if (draggedCard) {
        const deckRect = deck.getBoundingClientRect();
        const isOverDeck = e.clientX >= deckRect.left && e.clientX <= deckRect.right &&
          e.clientY >= deckRect.top && e.clientY <= deckRect.bottom;
        
        if (isOverDeck) {
          const topCard = document.querySelector('.top-card');
          if (draggedCard === topCard) {
            deck.appendChild(draggedCard);
          } else {
            cardArea.removeChild(draggedCard);
            topCard.style.visibility = 'visible';
          }
        } else {
          cardArea.removeChild(draggedCard);
          const newIndex = Array.from(cardContainer.children).indexOf(placeholder);
          cardContainer.insertBefore(draggedCard, newIndex === -1 ? null : cardContainer.children[newIndex]);

          draggedCard.style.position = '';
          draggedCard.style.left = '';
          draggedCard.style.top = '';
          draggedCard.classList.remove('dragged');

          placeholder.style.height = '';

          if (draggedCard.parentNode === deck) {
            drawCard();
          } else {
            currentCardIndex++; // Add this line to increment the index when a card is placed
            drawCard(); // Add this line to draw a new card when a card is placed
          }
        }

        updateCheckResultsButton();

        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);

        placeholder.style.width = '';

      }
    }


    const messageBox = document.getElementById('message-box');
    const messageText = document.getElementById('message-text');


    function restart() {
      // Suppress the "save changes" popup
      window.onbeforeunload = null;
    
      // Reload the page
      if (document.body.classList.contains('dark-mode')) {
        let url = new URL(window.location.href);
        url.searchParams.set('dark', 'enabled');
        window.location.href = url.href;
      } else {
        let url = new URL(window.location.href);
        url.searchParams.set('dark', 'disabled');
        window.location.href = url.href;
      }
    }
      /*
      while (cardContainer.firstChild) {
        cardContainer.removeChild(cardContainer.firstChild);
        console.log('1')
        console.log(document.getElementById('check-results-button').textContent)
      }

      console.log('2')
      console.log(document.getElementById('check-results-button').textContent)
      
      skipBtn.disabled = false;
      skipBtn.onclick = drawCard;
      hasInteracted=false;

      console.log('3')
      console.log(document.getElementById('check-results-button').textContent)

      const restartButton = document.getElementById('check-results-button');
      restartButton.disabled = true;
      restartButton.textContent = 'Check Results';
      restartButton.onclick = checkResults;

      console.log('4')
      console.log(document.getElementById('check-results-button').textContent)
      

      messageBox.classList.add('hidden');
      hasInteracted = false;

      console.log('5')
      console.log(document.getElementById('check-results-button').textContent)

      currentCardIndex = 0; // Reset the currentCardIndex to 0
      cardDeck = shuffle([...flashcards]);
      drawCard(); // Call drawCard() to display a new card
      */
    

    function hideMessageBox(duration) {
      setTimeout(() => {
        messageBox.classList.add('fade-out');
        setTimeout(() => {
          messageBox.classList.add('hidden');
          messageBox.classList.remove('fade-out');
        }, 1000);
      }, duration);
    }
    

    
    function checkResults() {
      let prevDate = null;
      let allCorrect = true;
    
      if (deck.querySelector('.top-card')) {
        deck.querySelector('.top-card').style.backgroundColor = 'rgba(192, 192, 192, 0.5)';
      }
    
      Array.from(cardContainer.children)
        .filter(child => child.classList.contains('card'))
        .forEach((card, index) => {
          const cardDate = Number(card.dataset.date);
          const isCorrect = prevDate === null || prevDate <= cardDate;
          allCorrect = allCorrect && isCorrect;
          card.style.backgroundColor = isCorrect ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
          prevDate = cardDate;
          card.draggable = false;
    
          if (!card.querySelector('.event-date')) {
            const eventDate = document.createElement('div');
            eventDate.classList.add('event-date');
            eventDate.textContent = card.dataset.date;
            card.prepend(eventDate);
          }
        });
    
    

      //const resultText = document.getElementById('check-results-button').textContent;
      
      if (allCorrect && cardContainer.children.length > 0) {
        messageText.textContent = ("Congratulations! You've successfully ordered the events.");
      } else if (cardContainer.children.length > 0) {
        messageText.textContent = ("Some events are not in the correct order. Please try again.");
        skipBtn.disabled = true;
      } else {
          const checkResultsButton = document.getElementById('check-results-button');
          checkResultsButton.disabled = false;
          checkResultsButton.textContent = 'Restart';
          checkResultsButton.onclick = restart;
          messageBox.classList.add('hidden');
          return;
      }

      messageBox.classList.remove('hidden');      

      const checkResultsButton = document.getElementById('check-results-button');
      checkResultsButton.disabled = false;
      checkResultsButton.textContent = 'Restart';
      checkResultsButton.onclick = restart;

      messageBox.classList.remove('hidden');
      hideMessageBox(1500);
      console.log(document.getElementById('check-results-button').textContent)
    }

    function toggleDarkMode() {
      isDarkMode = !isDarkMode;
    
      // Add or remove the 'dark-mode' class for each element
      document.body.classList.toggle('dark-mode', isDarkMode);
      deck.classList.toggle('dark-mode', isDarkMode);
      cardArea.classList.toggle('dark-mode', isDarkMode);
      messageBox.classList.toggle('dark-mode', isDarkMode);
    
      themeToggle.textContent = isDarkMode ? '☀️' : '🌙';
    }


    skipBtn.addEventListener('click', () => {
      currentCardIndex++;
      const newCardData = {
        name: newCard.textContent,
        date: newCard.dataset.date
      };
      cardDeck.push(newCardData);
      drawCard();
      hasInteracted = true;
    });

    checkBtn.addEventListener('click', () => {
      checkResults();
    });

    themeToggle.addEventListener('click', () => {
      toggleDarkMode();
    });

    window.addEventListener('beforeunload', (e) => {
      if (hasInteracted) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    document.getElementById('message-close').addEventListener('click', () => {
      document.getElementById('message-box').classList.add('hidden');
    });

    document.getElementById('check-results-button').onclick = checkResults;

    cardDeck = shuffle(cardDeck);
    drawCard();

    
    Sortable.create(cardContainer, {
      group: 'shared',
      animation: 150,
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      forceFallback: true, // Add this line
      fallbackClass: 'sortable-fallback', // Add this line
      swap: true, // Add this line
      swapThreshold: 0.5, // Add this line
      onAdd: updateCheckResultsButton,
      onUpdate: updateCheckResultsButton,
      onEnd: updateCheckResultsButton,
    });
    

  </script>
</body>

</html>
